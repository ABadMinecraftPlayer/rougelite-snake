<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Roguelite Snake</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #f0f0f0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 10vh;
            touch-action: manipulation;
            /* Disable double-tap zoom on mobile */
        }

        canvas {
            background-color: #111;
            border: 4px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(20, 20, 20, 0.95);
            border: 4px solid #444;
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .hidden {
            display: none;
        }

        /* Buttons */
        .btn {
            display: inline-block;
            background-color: #2a2a2a;
            border: 2px solid #555;
            color: #00ff00;
            padding: 1rem 1.5rem;
            margin-top: 1rem;
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px #00a000;
        }

        .btn:hover {
            background-color: #333;
            border-color: #777;
            transform: translateY(-2px);
            box-shadow: 0 6px #00c000;
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px #008000;
        }

        .btn-secondary {
            background-color: #331111;
            border-color: #772222;
            color: #ff4444;
            box-shadow: 0 4px #a00000;
        }

        .btn-secondary:hover {
            background-color: #441111;
            border-color: #992222;
            box-shadow: 0 6px #c00000;
        }

        .btn-secondary:active {
            box-shadow: 0 2px #800000;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            margin-left: 1rem;
        }

        /* Upgrade Item */
        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #222;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 2px solid #333;
            text-align: left;
        }

        .upgrade-info {
            flex-grow: 1;
        }

        .upgrade-info p {
            font-size: 0.8rem;
            margin: 0.25rem 0;
        }

        .upgrade-info .cost {
            color: #ffff00;
            font-weight: bold;
        }

        /* Checkbox Toggle */
        .toggle-label {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            margin-right: 10px;
        }

        .toggle-label input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 28px;
            border: 2px solid #555;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #aaa;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #00a000;
            border-color: #00ff00;
        }

        input:checked+.slider:before {
            transform: translateX(22px);
            background-color: #fff;
        }

        /* Game HUD (Top Center) */
        #game-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            color: #ffff00;
            font-size: 1.1rem;
            z-index: 5;
            min-width: 300px;
            text-align: center;
        }

        #touch-controls {
            position: absolute;
            bottom: 20px;
            width: 150px;
            height: 150px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            z-index: 20;
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            opacity: 0.7;
        }

        .touch-btn.pressed {
            transform: scale(0.92);
            opacity: 1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6) inset;
        }

        #touch-up {
            grid-column: 2;
            grid-row: 1;
        }

        #touch-left {
            grid-column: 1;
            grid-row: 2;
        }

        #touch-right {
            grid-column: 3;
            grid-row: 2;
        }

        #touch-down {
            grid-column: 2;
            grid-row: 3;
        }

        /* Card Choice UI */
        .card {
            background-color: #2a2a2a;
            border: 2px solid #555;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px #444;
        }

        .card:hover {
            background-color: #333;
            border-color: #00ff00;
            transform: translateY(-4px);
            box-shadow: 0 8px #00a000;
        }

        .card h3 {
            font-size: 1.25rem;
            color: #00ff00;
            margin-bottom: 0.5rem;
        }

        .card .buff {
            color: #f0f0f0;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .card .debuff {
            color: #ff4444;
            font-size: 0.8rem;
        }

        @media (min-width: 768px) {
            #touch-controls {
                display: none;
                /* Hide touch controls on larger screens */
            }
        }
    </style>
</head>

<body>

    <!-- Game Canvas -->
    <div id="game-container" class="relative">
        <!-- HUD is hidden by default and shown only in GAME state -->
        <div id="game-hud" class="hidden">
            <div id="score-display">SCORE: 0</div>
            <div id="speed-display">SPEED: 200ms</div>
            <div id="quota-display">QUOTA: 5</div>
            <div id="round-display">ROUND: 1</div>
            <!-- coins removed from HUD per request -->
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Main Menu UI -->
    <div id="main-menu" class="ui-panel">
        <h1 class="text-3xl text-green-400 mb-4">Roguelite Snake</h1>
        <p class="text-lg mb-2">Total Apple Coins: <span id="menu-coins" class="text-yellow-300">0</span></p>
        <!-- Speed removed from main menu as requested -->
        <p class="text-base mb-2">Highest Round: <span id="menu-high-round" class="text-yellow-300">0</span></p>
        <p class="text-base mb-6">Highest Score: <span id="menu-high-score" class="text-yellow-300">0</span></p>
        <button id="start-game-btn" class="btn w-full">Start Game</button>
        <button id="upgrades-btn" class="btn w-full">Upgrades</button>
        <button id="achievements-btn" class="btn w-full">Achievements</button>
    </div>

    <!-- Game Over UI -->
    <div id="game-over-menu" class="ui-panel hidden">
        <h1 class="text-3xl text-red-500 mb-4">GAME OVER</h1>
        <p class="text-lg mb-2">Final Score: <span id="final-score" class="text-white">0</span></p>
        <p class="text-lg mb-2">Rounds Reached: <span id="final-round" class="text-white">0</span></p>
        <!-- Coins earned this run - kept in game over for clarity, but HUD coins removed -->
        <p class="text-lg mb-2">A. Coins Earned: <span id="coins-earned-run" class="text-yellow-300">0</span></p>
        <p class="text-lg mb-6">Total Apple Coins: <span id="final-total-coins" class="text-yellow-300">0</span></p>
        <button id="restart-btn" class="btn w-full">Main Menu</button>
    </div>

    <!-- Card Choice UI -->
    <div id="card-choice-menu" class="ui-panel hidden">
        <h1 class="text-2xl text-yellow-300 mb-4">CHOOSE A BOOSTER</h1>
        <div id="card-options">
            <!-- Cards will be injected here by JS -->
        </div>
    </div>

    <!-- Upgrades UI -->
    <div id="upgrades-menu" class="ui-panel hidden">
        <h1 class="text-2xl text-yellow-300 mb-4">UPGRADES</h1>
        <!-- Keeping this visible as it's essential for using the upgrade screen -->
        <p class="text-lg mb-6">Available Coins: <span id="upgrade-coins" class="text-yellow-300">0</span></p>

        <!-- Upgrade Item 1: Apple Spawn Rate -->
        <div class="upgrade-item">
            <div class="upgrade-info">
                <p class="text-green-400">Apple Abundance</p>
                <p>Increases apple spawn rate.</p>
                <p>Current: <span id="apple-rate-value">1</span></p>
                <p class="cost">Cost: <span id="apple-rate-cost">10</span> Coins</p>
            </div>
            <div>
                <button id="buy-apple-rate" class="btn btn-small">Buy</button>
            </div>
        </div>

        <!-- Upgrade Item 2: Starting Length (Example) -->
        <div class="upgrade-item">
            <div class="upgrade-info">
                <p class="text-blue-400">Long Start</p>
                <p>Start with a longer snake.</p>
                <p class="cost">Current: <span id="start-length-value">3</span></p>
                <p class="cost">Cost: <span id="start-length-cost">25</span> Coins</p>
            </div>
            <div>
                <button id="buy-start-length" class="btn btn-small">Buy</button>
            </div>
        </div>

        <h2 class="text-xl text-gray-400 mt-8 mb-4">Toggle Upgrades</h2>
        <div class="upgrade-item">
            <label class="toggle-label">
                <input type="checkbox" id="toggle-apple-rate">
                <span class="slider"></span>
            </label>
            <span class="text-sm">Apple Abundance (Active)</span>
        </div>
        <div class="upgrade-item">
            <label class="toggle-label">
                <input type="checkbox" id="toggle-start-length">
                <span class="slider"></span>
            </label>
            <span class="text-sm">Long Start (Active)</span>
        </div>

        <button id="back-to-menu-btn" class="btn btn-secondary w-full mt-8">Back to Menu</button>
    </div>

    <!-- Achievements UI -->
    <div id="achievements-menu" class="ui-panel hidden">
        <h1 class="text-2xl text-yellow-300 mb-4">ACHIEVEMENTS</h1>
        <div id="achievements-list" class="text-left mb-6">
            <!-- Achievements will be populated here -->
        </div>
        <button id="close-achievements-btn" class="btn btn-secondary w-full mt-4">Back</button>
    </div>

    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="hidden">
        <button id="touch-up" class="touch-btn">▲</button>
        <button id="touch-left" class="touch-btn">◄</button>
        <button id="touch-right" class="touch-btn">►</button>
        <button id="touch-down" class="touch-btn">▼</button>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Game Constants ---
            const GRID_SIZE = 20; // Static 20x20 grid
            let TILE_SIZE = 20;   // Size of each tile in pixels

            // --- Game Elements ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // UI Panels
            const mainMenu = document.getElementById('main-menu');
            const gameOverMenu = document.getElementById('game-over-menu');
            const upgradesMenu = document.getElementById('upgrades-menu');
            const achievementsMenu = document.getElementById('achievements-menu');
            const gameHud = document.getElementById('game-hud');
            const touchControls = document.getElementById('touch-controls');

            // UI Buttons
            const startGameBtn = document.getElementById('start-game-btn');
            const upgradesBtn = document.getElementById('upgrades-btn');
            const restartBtn = document.getElementById('restart-btn');
            const backToMenuBtn = document.getElementById('back-to-menu-btn');
            const buyAppleRateBtn = document.getElementById('buy-apple-rate');
            const buyStartLengthBtn = document.getElementById('buy-start-length');
            const achievementsBtn = document.getElementById('achievements-btn');
            const closeAchievementsBtn = document.getElementById('close-achievements-btn');

            // UI Toggles
            const toggleAppleRate = document.getElementById('toggle-apple-rate');
            const toggleStartLength = document.getElementById('toggle-start-length');

            // UI Readouts
            const menuCoins = document.getElementById('menu-coins');
            const upgradeCoins = document.getElementById('upgrade-coins');
            const finalScore = document.getElementById('final-score');
            const scoreDisplay = document.getElementById('score-display');
            const speedDisplay = document.getElementById('speed-display');
            const menuHighRound = document.getElementById('menu-high-round');
            const menuHighScore = document.getElementById('menu-high-score');
            const roundDisplay = document.getElementById('round-display');
            const quotaDisplay = document.getElementById('quota-display');
            const finalRound = document.getElementById('final-round');

            // NEW: game over coin readouts
            const coinsEarnedRunEl = document.getElementById('coins-earned-run');
            const finalTotalCoinsEl = document.getElementById('final-total-coins');

            // Card UI
            const cardChoiceMenu = document.getElementById('card-choice-menu');
            const cardOptions = document.getElementById('card-options');

            // Upgrade Readouts
            const appleRateValue = document.getElementById('apple-rate-value');
            const appleRateCost = document.getElementById('apple-rate-cost');
            const startLengthValue = document.getElementById('start-length-value');
            const startLengthCost = document.getElementById('start-length-cost');
            const achievementsListEl = document.getElementById('achievements-list');

            // --- Game State ---
            let gameState = 'MENU'; // MENU, GAME, UPGRADES, GAME_OVER, CARD_CHOICE, ACHIEVEMENTS
            let snake, apples, obstacles, direction, newDirection, score, gameLoopInterval;
            let lives, roundCounter, scoreQuota, currentGridSize;
            let activeBuffs = {};
            let generatedCards = [];
            // inputBuffer holds one or two queued directions so player input isn't frame-perfect
            let inputBuffer = [];
            // Canonical permanent speed stat (in ms). User requested base 200ms.
            let speedStat = 200; // Speed stat (min 150, max 250)
            let gameSpeed = speedStat; // actual loop delay; will be derived from speedStat + temporary buffs
            let runInitialScore = 10; // Score at the start of the entire run (default 10)
            let isPausedAfterDeath = false; // Flag to track if paused after death

            // --- Persistent Roguelite State ---
            let persistentState = {
                appleCoins: 0,
                highestRound: 0,
                highestScore: 0,
                upgrades: {
                    appleSpawnRateLevel: 0,
                    startLengthLevel: 0
                },
                activeUpgrades: {
                    appleSpawnRate: true,
                    startLength: true
                },
                achievements: {
                    fastestSpeed: false,
                    slowestSpeed: false,
                    halfFull: false,
                    fullWithUpgrades: false,
                    fullWithoutUpgrades: false
                }
            };

            const BASE_APPLE_SPAWN_RATE = 0.02;
            const APPLE_RATE_INCREASE = 0.0025;
            // New: fixed apple count per level system
            const BASE_APPLE_COUNT = 1; // start with 1 apple (changed per request)
            const APPLES_PER_UPGRADE = 1; // each upgrade adds 1 apple
            // Maximum apples a player can have via upgrades
            const MAX_APPLE_COUNT = 50;
            const MAX_APPLE_LEVEL = MAX_APPLE_COUNT - BASE_APPLE_COUNT; // max upgrade levels for apples
            const BASE_START_LENGTH = 1;
            const START_LENGTH_INCREASE = 1;
            const INITIAL_SCORE = 1; // Requested starting score
            // Max start length (permanent upgrade cap)
            const MAX_START_LENGTH = 10;
            const MAX_START_LENGTH_LEVEL = MAX_START_LENGTH - BASE_START_LENGTH; // number of upgrade levels to reach max

            // --- Card Database ---
            const cardDatabase = [
                {
                    id: "APPLE_BOOM",
                    title: "Apple Boom",
                    buff: "Instantly spawns 3 extra apples.",
                    debuff: null,
                    applyEffect: () => {
                        spawnSingleApple();
                        spawnSingleApple();
                        spawnSingleApple();
                    }
                },
                // TURBO_STARTER (hasty ability) removed per request
                {
                    id: "CAREFUL_CRAWLER",
                    title: "Careful Crawler",
                    buff: "+10ms Speed Stat.",
                    debuff: "-2 Score and Snake length reduced by 2.",
                    applyEffect: () => {
                        score = Math.max(0, score - 2);
                        // Get the starting length to know how much we can safely remove
                        const startLength = persistentState.activeUpgrades.startLength
                            ? BASE_START_LENGTH + (persistentState.upgrades.startLengthLevel * START_LENGTH_INCREASE)
                            : BASE_START_LENGTH;
                        // Instant length decrease (remove 2 segments from the tail end)
                        for (let i = 0; i < 2 && snake.length > startLength; i++) {
                            snake.pop();
                        }

                        // Apply speed buff - increase speed stat by 10 (maximum 250)
                        speedStat = Math.min(250, speedStat + 10);
                        updateHud();
                    }
                },
                {
                    id: "GHOST",
                    title: "Ghost Form",
                    buff: "Pass through your own tail for 10 seconds.",
                    debuff: null,
                    applyEffect: () => {
                        activeBuffs.ghost = 100;
                    }
                },
                {
                    id: "COIN_BONUS",
                    title: "Investment",
                    buff: "Instantly gain 10 Apple Coins.",
                    debuff: null,
                    applyEffect: () => {
                        persistentState.appleCoins += 10;
                        updateHud();
                        saveState();
                    }
                }
            ];

            // --- Game Logic ---

            // --- Input helpers ---
            function isOpposite(a, b) {
                if (!a || !b) return false;
                return a.x === -b.x && a.y === -b.y;
            }

            function queueDirection(dir) {
                // Ignore null/invalid
                if (!dir) return;
                // Don't queue a direct reverse of current direction
                if (direction && isOpposite(dir, direction)) return;
                // If buffer empty, push; otherwise overwrite the single queued input
                if (inputBuffer.length === 0) inputBuffer.push(dir);
                else inputBuffer[0] = dir;
            }


            function initializeGame() {
                loadState();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Keyboard Input (buffered)
                document.addEventListener('keydown', e => {
                    if (gameState !== 'GAME') return;

                    // If paused after death, any input resumes the game
                    if (isPausedAfterDeath) {
                        isPausedAfterDeath = false;
                        canvas.style.backgroundColor = '#111';
                        if (gameLoopInterval) clearInterval(gameLoopInterval);
                        gameLoopInterval = setInterval(gameLoop, gameSpeed);
                        return;
                    }

                    const key = e.key;
                    if (key === 'ArrowUp' || key === 'w') queueDirection({ x: 0, y: -1 });
                    else if (key === 'ArrowDown' || key === 's') queueDirection({ x: 0, y: 1 });
                    else if (key === 'ArrowLeft' || key === 'a') queueDirection({ x: -1, y: 0 });
                    else if (key === 'ArrowRight' || key === 'd') queueDirection({ x: 1, y: 0 });
                });

                // Touch / on-screen controls (buffered & pointer events for better responsiveness)
                const btnUp = document.getElementById('touch-up');
                const btnDown = document.getElementById('touch-down');
                const btnLeft = document.getElementById('touch-left');
                const btnRight = document.getElementById('touch-right');

                const addPointerHandlers = (el, dir) => {
                    el.addEventListener('pointerdown', (ev) => {
                        ev.preventDefault();
                        if (gameState !== 'GAME') return;
                        if (isPausedAfterDeath) {
                            isPausedAfterDeath = false;
                            canvas.style.backgroundColor = '#111';
                            if (gameLoopInterval) clearInterval(gameLoopInterval);
                            gameLoopInterval = setInterval(gameLoop, gameSpeed);
                            return;
                        }
                        queueDirection(dir);
                        el.classList.add('pressed');
                    });
                    const clear = () => el.classList.remove('pressed');
                    el.addEventListener('pointerup', clear);
                    el.addEventListener('pointercancel', clear);
                    el.addEventListener('pointerleave', clear);
                };

                addPointerHandlers(btnUp, { x: 0, y: -1 });
                addPointerHandlers(btnDown, { x: 0, y: 1 });
                addPointerHandlers(btnLeft, { x: -1, y: 0 });
                addPointerHandlers(btnRight, { x: 1, y: 0 });

                // UI Button Listeners
                startGameBtn.addEventListener('click', startGame);
                upgradesBtn.addEventListener('click', showUpgradesMenu);
                restartBtn.addEventListener('click', showMainMenu);
                backToMenuBtn.addEventListener('click', showMainMenu);
                achievementsBtn.addEventListener('click', showAchievementsMenu);
                closeAchievementsBtn.addEventListener('click', showMainMenu);

                // Buy Listeners
                buyAppleRateBtn.addEventListener('click', () => buyUpgrade('appleSpawnRateLevel'));
                buyStartLengthBtn.addEventListener('click', () => buyUpgrade('startLengthLevel'));

                // Toggle Listeners
                toggleAppleRate.addEventListener('change', () => toggleUpgradeActive('appleSpawnRate'));
                toggleStartLength.addEventListener('change', () => toggleUpgradeActive('startLength'));

                showMainMenu();
            }

            function resizeCanvas() {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Use GRID_SIZE for current sizing
                const size = Math.min(viewportWidth, viewportHeight) * 0.9;

                TILE_SIZE = Math.floor(size / GRID_SIZE);
                canvas.width = TILE_SIZE * GRID_SIZE;
                canvas.height = TILE_SIZE * GRID_SIZE;
            }

            function updateUIState() {
                // Hide all panels
                mainMenu.classList.add('hidden');
                gameOverMenu.classList.add('hidden');
                upgradesMenu.classList.add('hidden');
                cardChoiceMenu.classList.add('hidden');
                gameHud.classList.add('hidden'); // Hide HUD globally first
                touchControls.classList.add('hidden');
                achievementsMenu.classList.add('hidden');

                // Show the current panel
                if (gameState === 'MENU') {
                    mainMenu.classList.remove('hidden');
                } else if (gameState === 'GAME') {
                    // Show in-game elements
                    gameHud.classList.remove('hidden');
                    touchControls.classList.remove('hidden');
                } else if (gameState === 'GAME_OVER') {
                    gameOverMenu.classList.remove('hidden');
                } else if (gameState === 'UPGRADES') {
                    upgradesMenu.classList.remove('hidden');
                    updateUpgradesUI();
                } else if (gameState === 'CARD_CHOICE') {
                    cardChoiceMenu.classList.remove('hidden');
                    displayCardChoices();
                } else if (gameState === 'ACHIEVEMENTS') {
                    achievementsMenu.classList.remove('hidden');
                    displayAchievements();
                }
            }

            function showMainMenu() {
                gameState = 'MENU';
                // Update menu display with current coins and highest round/score
                menuCoins.textContent = persistentState.appleCoins;
                menuHighRound.textContent = persistentState.highestRound;
                menuHighScore.textContent = persistentState.highestScore;
                updateUIState();
                drawMenuBackground();
            }

            function showUpgradesMenu() {
                gameState = 'UPGRADES';
                updateUIState();
            }

            function showAchievementsMenu() {
                gameState = 'ACHIEVEMENTS';
                updateUIState();
            }

            function drawMenuBackground() {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = '#222';
                for (let i = 0; i < GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * TILE_SIZE, 0);
                    ctx.lineTo(i * TILE_SIZE, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * TILE_SIZE);
                    ctx.lineTo(canvas.width, i * TILE_SIZE);
                    ctx.stroke();
                }

                ctx.fillStyle = 'rgba(0, 255, 0, 0.9)'; // almost fully opaque
                ctx.font = `${TILE_SIZE * 2}px 'Press Start 2P'`;
                ctx.textAlign = 'center';

                const text = "ROUGE SNAKE"; // or any long text
                const maxWidth = canvas.width * 0.95; // max width before wrapping
                const words = text.split(' ');
                let line = '';
                let lines = [];

                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && i > 0) {
                        lines.push(line);
                        line = words[i] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line);

                // Draw each line
                const startY = canvas.height / 2 - (lines.length - 1) * TILE_SIZE; // center vertically
                lines.forEach((ln, idx) => {
                    ctx.fillText(ln.trim(), canvas.width / 2, startY + idx * TILE_SIZE * 2);
                });
            }

            function startGame() {
                // 1. Initialize run state
                runInitialScore = INITIAL_SCORE; // Reset run base score for new game
                score = runInitialScore;
                roundCounter = 1;
                currentGridSize = GRID_SIZE; // Fixed size
                scoreQuota = 5;
                activeBuffs = {};
                // Start with the canonical speed stat
                gameSpeed = speedStat;

                // 2. Change UI and setup first level
                gameState = 'GAME';
                setupLevel();
            }

            function setupLevel() {
                // 1. Only initialize snake if it doesn't exist (first game start)
                if (!snake || snake.length === 0) {
                    const startLength = persistentState.activeUpgrades.startLength
                        ? BASE_START_LENGTH + (persistentState.upgrades.startLengthLevel * START_LENGTH_INCREASE)
                        : BASE_START_LENGTH;

                    // 2. Initialize level state
                    snake = [];
                    // Starting score depends on starting snake length
                    score = startLength;
                    const spawnPoint = { x: Math.floor(currentGridSize / 2), y: Math.floor(currentGridSize / 2) };
                    for (let i = 0; i < startLength; i++) {
                        snake.push({ x: spawnPoint.x - i, y: spawnPoint.y });
                    }

                    // Initialize direction only on first game start
                    direction = { x: 1, y: 0 };
                    newDirection = { x: 1, y: 0 };
                }
                // If snake exists, keep it where it is - don't reset position

                // Don't reset direction - keep the current direction
                obstacles = [];

                updateHud();

                // 3. Generate map and food (keep existing apples)
                const spawnPoint = { x: Math.floor(currentGridSize / 2), y: Math.floor(currentGridSize / 2) };
                generateProceduralMap(spawnPoint);
                // Don't reset apples - only spawn if this is the first level
                if (!apples || apples.length === 0) {
                    spawnInitialApples();
                }

                // 4. Change UI and start loop
                updateUIState();

                // 5. Apply speed effects (persistent across levels). Base comes from speedStat.
                let currentSpeed = speedStat; // canonical permanent stat (ms)

                // Check for slowed/fast modifiers - they multiply the base
                if (activeBuffs.slowed) {
                    currentSpeed = currentSpeed * 1.2; // 20% slower
                }
                if (activeBuffs.fast) {
                    currentSpeed = currentSpeed * 0.8; // 20% faster
                }

                // Ensure integer ms and a reasonable lower bound
                gameSpeed = Math.max(50, Math.round(currentSpeed));

                if (gameLoopInterval) clearInterval(gameLoopInterval);
                gameLoopInterval = setInterval(gameLoop, gameSpeed);
            }

            function gameLoop() {
                update();
                draw();
            }

            function update() {
                // Update active buffs (Ghost duration)
                if (activeBuffs.ghost > 0) {
                    activeBuffs.ghost--;
                    if (activeBuffs.ghost === 0) {
                        // Ghost effect wears off
                    }
                }

                // Consume a buffered input (if any) at the start of the tick.
                while (inputBuffer.length > 0) {
                    const candidate = inputBuffer.shift();
                    // If candidate is not a direct reverse of current direction, accept it
                    if (!isOpposite(candidate, direction)) {
                        newDirection = candidate;
                        break;
                    }
                    // otherwise drop and continue
                }

                direction = newDirection;
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

                // --- Check Collisions ---

                // Self-collision (treat snake body as obstacle)
                // NEW: allow passing through your own body while ghost buff is active,
                // but still collide with obstacles (borders).
                if (!(activeBuffs.ghost > 0)) {
                    for (let i = 1; i < snake.length; i++) {
                        if (head.x === snake[i].x && head.y === snake[i].y) {
                            return handleDeath();
                        }
                    }
                } else {
                    // Ghost mode: no self-collision — the player can pass through their own tail.
                }

                // Obstacle collision (includes border walls)
                if (obstacles.some(o => o.x === head.x && o.y === head.y)) {
                    return handleDeath();
                }

                snake.unshift(head); // Add new head

                // --- Check Apple Eat ---
                let ateApple = false;
                const appleIndex = apples.findIndex(a => a.x === head.x && a.y === head.y);

                if (appleIndex > -1) {
                    ateApple = true;
                    score++;
                    apples.splice(appleIndex, 1); // Remove eaten apple
                    spawnSingleApple(); // Spawn a new one
                    updateHud();

                    // Check achievements (length increased)
                    checkAchievements();

                    // Check for max size bonus
                    const maxTiles = (currentGridSize * currentGridSize) - obstacles.length;
                    if (snake.length >= maxTiles) {
                        persistentState.appleCoins += 50; // Bonus!
                        saveState();
                        handleLevelWin();
                    }
                    // Check for score quota
                    else if (score >= scoreQuota) {
                        handleLevelWin();
                    }
                }

                if (!ateApple) {
                    snake.pop(); // Remove tail
                }
            }

            function draw() {
                // Clear canvas
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw obstacles
                ctx.fillStyle = '#444';
                obstacles.forEach(o => {
                    ctx.fillRect(o.x * TILE_SIZE, o.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                });

                // Draw apples
                ctx.fillStyle = '#ff0000'; // Red
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(255, 0, 0, 0.7)";
                apples.forEach(a => {
                    ctx.fillRect(a.x * TILE_SIZE, a.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                });
                ctx.shadowBlur = 0; // Reset shadow

                // Draw snake
                // Ghost visual: make the snake translucent when ghost active
                if (activeBuffs.ghost > 0) {
                    ctx.globalAlpha = 0.6; // Ghost effect
                }
                snake.forEach((segment, index) => {
                    // Head is slightly brighter
                    ctx.fillStyle = index === 0 ? '#55ff55' : '#00ff00';
                    ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                });
                ctx.globalAlpha = 1.0; // Reset alpha
            }

            function updateHud() {
                scoreDisplay.textContent = `SCORE: ${score}`;
                roundDisplay.textContent = `ROUND: ${roundCounter}`;
                quotaDisplay.textContent = `QUOTA: ${scoreQuota}`;
                if (speedDisplay) speedDisplay.textContent = `SPEED: ${speedStat}ms`;
                if (menuHighScore) menuHighScore.textContent = persistentState.highestScore;
            }

            function handleDeath() {
                // Only one life - game over immediately
                clearInterval(gameLoopInterval);
                triggerGameOver();
            }

            function handleLevelWin() {
                clearInterval(gameLoopInterval);
                gameState = 'CARD_CHOICE';
                generatedCards = generateBoosterCards();
                updateUIState();
            }

            function triggerGameOver() {
                clearInterval(gameLoopInterval);

                // --- Reset speed to base ---
                speedStat = 200; // base canonical speed (ms)
                gameSpeed = speedStat;

                gameState = 'GAME_OVER';

                // Calculate earned coins for this run
                let earned = Math.floor(score / 2);
                persistentState.appleCoins += earned;

                if (roundCounter > persistentState.highestRound) {
                    persistentState.highestRound = roundCounter;
                }
                if (score > persistentState.highestScore) {
                    persistentState.highestScore = score;
                }
                saveState();

                finalScore.textContent = score;
                finalRound.textContent = roundCounter;

                // Update Game Over coin displays
                coinsEarnedRunEl.textContent = earned;
                finalTotalCoinsEl.textContent = persistentState.appleCoins;

                // Reset game objects
                snake = [];
                apples = [];
                obstacles = [];
                activeBuffs = {};
                isPausedAfterDeath = false;

                updateUIState();
            }

            // --- Map & Food Generation ---

            function generateProceduralMap(spawnPoint) {
                obstacles = [];
                currentGridSize = GRID_SIZE; // Ensure it's fixed to 20

                // Add border walls (Mandatory obstacles)
                for (let i = 0; i < currentGridSize; i++) {
                    obstacles.push({ x: i, y: 0 });          // Top
                    obstacles.push({ x: i, y: currentGridSize - 1 }); // Bottom
                    obstacles.push({ x: 0, y: i });          // Left
                    obstacles.push({ x: currentGridSize - 1, y: i }); // Right
                }

                // NO RANDOM INTERNAL ROCKS
            }

            function spawnInitialApples() {
                apples = [];
                // Use fixed apple count: base + upgrades
                const appleLevel = persistentState.upgrades.appleSpawnRateLevel || 0;
                const numApples = BASE_APPLE_COUNT + (appleLevel * APPLES_PER_UPGRADE);
                for (let i = 0; i < numApples; i++) spawnSingleApple();
            }

            function spawnSingleApple() {
                let pos = getRandomEmptyPosition();
                if (pos) {
                    apples.push(pos);
                }
            }

            function getRandomEmptyPosition() {
                let pos;
                let attempts = 0;
                const maxAttempts = currentGridSize * currentGridSize;

                while (attempts < maxAttempts) {
                    pos = {
                        x: Math.floor(Math.random() * (currentGridSize - 2)) + 1, // Avoid borders
                        y: Math.floor(Math.random() * (currentGridSize - 2)) + 1
                    };

                    if (isPositionEmpty(pos)) {
                        return pos;
                    }
                    attempts++;
                }
                return null;
            }

            function isPositionEmpty(pos) {
                if (snake.some(s => s.x === pos.x && s.y === pos.y)) return false;
                if (apples.some(a => a.x === pos.x && a.y === pos.y)) return false;
                if (obstacles.some(o => o.x === pos.x && o.y === pos.y)) return false;
                return true;
            }

            // --- Card Choice Logic ---

            function generateBoosterCards() {
                // Filter out speed-affecting cards when at bounds so they don't spawn unnecessarily
                let availableCards = cardDatabase.filter(c => {
                    // If at maximum speed, don't offer further speeders
                    if (speedStat >= 250 && (c.id === 'CAREFUL_CRAWLER')) return false;
                    return true;
                });
                availableCards = [...availableCards];
                let chosenCards = [];

                for (let i = 0; i < 3; i++) {
                    if (availableCards.length === 0) break;

                    let randIndex = Math.floor(Math.random() * availableCards.length);
                    chosenCards.push(availableCards[randIndex]);
                    availableCards.splice(randIndex, 1);
                }
                return chosenCards;
            }

            function displayCardChoices() {
                cardOptions.innerHTML = '';
                generatedCards.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card';
                    cardEl.innerHTML = `
                        <h3>${card.title}</h3>
                        <p class="buff">${card.buff}</p>
                        ${card.debuff ? `<p class="debuff">${card.debuff}</p>` : ''}
                    `;
                    cardEl.addEventListener('click', () => selectCard(index));
                    cardOptions.appendChild(cardEl);
                });
            }

            function selectCard(index) {
                const card = generatedCards[index];
                card.applyEffect();

                // Increase quota for next booster (no round counter)
                scoreQuota = Math.floor(scoreQuota * 1.5) + 5;

                // Speed persists - do not reset after this level

                gameState = 'GAME';
                setupLevel();
            }

            // --- Achievements ---
            function checkAchievements() {
                const playable = (currentGridSize * currentGridSize) - obstacles.length;

                if (speedStat <= 150) persistentState.achievements.fastestSpeed = true;
                if (speedStat >= 250) persistentState.achievements.slowestSpeed = true;
                if (snake.length >= Math.floor(playable / 2)) persistentState.achievements.halfFull = true;
                if (snake.length >= playable) {
                    if ((persistentState.upgrades.appleSpawnRateLevel || 0) > 0 || (persistentState.upgrades.startLengthLevel || 0) > 0) {
                        persistentState.achievements.fullWithUpgrades = true;
                    } else {
                        persistentState.achievements.fullWithoutUpgrades = true;
                    }
                }
                saveState();
            }

            function displayAchievements() {
                achievementsListEl.innerHTML = '';
                const ach = persistentState.achievements;
                const items = [
                    { id: 'fastestSpeed', title: 'The Rabbit', desc: 'Reach the minimum speed (150ms)\n' },
                    { id: 'slowestSpeed', title: 'The Turtle', desc: 'Reach the maximum speed (250ms)\n' },
                    { id: 'halfFull', title: 'Half full or half empty?', desc: 'Fill half of the playable board.' },
                    { id: 'fullWithUpgrades', title: 'Gamer', desc: 'Fill the entire board while having permanent upgrades.' },
                    { id: 'fullWithoutUpgrades', title: 'Hardcore Gamer', desc: 'Fill the entire board without permanent upgrades.' }
                ];

                items.forEach(it => {
                    const el = document.createElement('div');
                    el.style.padding = '8px 0';
                    el.style.borderBottom = '1px solid rgba(255,255,255,0.06)';
                    el.innerHTML = `
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div>
                                <div style="color:#00ff00;font-weight:bold;">${it.title}</div>
                                <div style="font-size:12px;color:#cccccc;">${it.desc}</div>
                            </div>
                            <div style="font-weight:bold;">${ach[it.id] ? 'UNLOCKED' : 'LOCKED'}</div>
                        </div>
                    `;
                    achievementsListEl.appendChild(el);
                });
            }

            // --- Roguelite Systems (Upgrades & Save/Load) ---

            function getUpgradeCost(level) {
                return Math.floor(10 * Math.pow(1.5, level));
            }

            function updateUpgradesUI() {
                upgradeCoins.textContent = persistentState.appleCoins;

                // Apple Rate Upgrade
                const appleLevel = persistentState.upgrades.appleSpawnRateLevel || 0;
                const currentAppleCount = BASE_APPLE_COUNT + (appleLevel * APPLES_PER_UPGRADE);
                appleRateValue.textContent = `${currentAppleCount} apples`;
                // If at max apple level, show MAX and disable buy button
                if (appleLevel >= MAX_APPLE_LEVEL) {
                    appleRateCost.textContent = 'MAX';
                    if (buyAppleRateBtn) {
                        buyAppleRateBtn.disabled = true;
                        buyAppleRateBtn.classList.add('opacity-50');
                    }
                } else {
                    appleRateCost.textContent = getUpgradeCost(appleLevel);
                    if (buyAppleRateBtn) {
                        buyAppleRateBtn.disabled = false;
                        buyAppleRateBtn.classList.remove('opacity-50');
                    }
                }
                toggleAppleRate.checked = persistentState.activeUpgrades.appleSpawnRate;

                // Start Length Upgrade
                const lengthLevel = persistentState.upgrades.startLengthLevel;
                const currentStartLength = BASE_START_LENGTH + (lengthLevel * START_LENGTH_INCREASE);
                startLengthValue.textContent = currentStartLength;
                startLengthCost.textContent = getUpgradeCost(lengthLevel);
                toggleStartLength.checked = persistentState.activeUpgrades.startLength;
                // Disable buy button when start length is maxed
                if (lengthLevel >= MAX_START_LENGTH_LEVEL) {
                    buyStartLengthBtn.disabled = true;
                    buyStartLengthBtn.classList.add('opacity-50');
                    // show 'MAX' instead of cost
                    startLengthCost.textContent = 'MAX';
                } else {
                    buyStartLengthBtn.disabled = false;
                    buyStartLengthBtn.classList.remove('opacity-50');
                }
            }

            function buyUpgrade(upgradeName) {
                const level = persistentState.upgrades[upgradeName];
                const cost = getUpgradeCost(level);

                // Prevent exceeding max start-length level
                if (upgradeName === 'startLengthLevel' && level >= MAX_START_LENGTH_LEVEL) {
                    console.log('Start length is already at maximum.');
                    return;
                }

                // Prevent exceeding max apple level
                if (upgradeName === 'appleSpawnRateLevel' && level >= MAX_APPLE_LEVEL) {
                    console.log('Apple count is already at maximum.');
                    return;
                }

                if (persistentState.appleCoins >= cost) {
                    persistentState.appleCoins -= cost;
                    persistentState.upgrades[upgradeName]++;
                    saveState();
                    updateUpgradesUI();
                } else {
                    console.log("Not enough coins!");
                }
            }

            function toggleUpgradeActive(upgradeName) {
                persistentState.activeUpgrades[upgradeName] = !persistentState.activeUpgrades[upgradeName];
                saveState();
                updateUpgradesUI();
            }

            function saveState() {
                localStorage.setItem('rogueSnakeState', JSON.stringify(persistentState));
            }

            function loadState() {
                const savedState = localStorage.getItem('rogueSnakeState');
                if (savedState) {
                    persistentState = JSON.parse(savedState);
                    // Ensure compatibility with older saves
                    if (!persistentState.upgrades.startLengthLevel && persistentState.upgrades.startLengthLevel !== 0) {
                        persistentState.upgrades.startLengthLevel = 0;
                    }
                    if (persistentState.activeUpgrades.startLength === undefined) {
                        persistentState.activeUpgrades.startLength = true;
                    }
                    if (persistentState.highestRound === undefined) {
                        persistentState.highestRound = 0;
                    }
                    if (persistentState.highestScore === undefined) {
                        persistentState.highestScore = 0;
                    }
                    if (!persistentState.achievements) {
                        persistentState.achievements = {
                            fastestSpeed: false,
                            slowestSpeed: false,
                            halfFull: false,
                            fullWithUpgrades: false,
                            fullWithoutUpgrades: false
                        };
                    }
                }
            }

            // --- Start ---
            initializeGame();
        });
    </script>
</body>

</html>